# File: .\coord2region.py
import numpy as np
from typing import Any, Dict, List, Optional, Union, Tuple
from .fetching import AtlasFetcher

class AtlasRegionMapper:
    """
    Holds a single atlas and its metadata, and provides methods to query region labels and coordinates.

    Parameters
    ----------
    :param name: Human-readable identifier of the atlas (e.g., "aal" or "brodmann").
    :param vol: 3D array (I, J, K) representing the atlas, where each voxel contains a region index.
    :param hdr: 4x4 affine transform for voxel-to-world (MNI) coordinates.
    :param labels: Mapping of region indices to region names. Can be a dictionary (keys as strings) or an array-like.
    :param index: Explicit numeric indices corresponding to `labels`. If `labels` is a dict, this can be left as None.
    :param system: The anatomical coordinate space (e.g., "mni", "tal", "unknown").

    Attributes
    ----------
    :attr name: Human-readable identifier of the atlas.
    :attr vol: 3D array representing the atlas.
    :attr hdr: 4x4 affine transform for voxel-to-world (MNI) coordinates.
    :attr labels: Mapping of region indices to region names.
    :attr index: Explicit numeric indices corresponding to `labels`.
    :attr system: The anatomical coordinate space.
    """

    def __init__(self,
                 name: str,
                 vol: np.ndarray,
                 hdr: np.ndarray,
                 labels: Optional[Union[Dict[str, str], List[str], np.ndarray]] = None,
                 index: Optional[Union[List[int], np.ndarray]] = None,
                 system: str = 'mni') -> None:
        self.name = name
        self.vol = np.asarray(vol)
        self.hdr = np.asarray(hdr)
        self.labels = labels
        self.index = index
        self.system = system
        # TODO: Add support for surf based atlases (mne)
        # Basic checks
        # TODO: check for vol and hdr only when working with volume based atlases and addd support for surf atlases
        if self.vol.ndim != 3:
            raise ValueError("`vol` must be a 3D numpy array.")
        if self.hdr.shape != (4, 4):
            raise ValueError("`hdr` must be a 4x4 transform matrix.")

        self.shape = self.vol.shape

        # If labels is a dict, prepare an inverse mapping.
        if isinstance(self.labels, dict):
            self._label2index = {v: k for k, v in self.labels.items()}
        else:
            self._label2index = None

    # --- Region Mapping Methods ---

    def _get_region_name(self, value: Union[int, str]) -> str:
        """
        Get the region label corresponding from an index.
        
        :param value: The region index or label. Must be an int or str.
        :return: The region name.

        If `labels` is a dict, lookup is performed using string keys.
        If `labels` is array-like with a corresponding `index` array, the position is found.
        Returns "Unknown" if not found.
        """
        if not isinstance(value, (int, str)):
            raise ValueError("value must be an int or str")
        value_str = str(value)
        if isinstance(self.labels, dict):
            return self.labels.get(value_str, "Unknown")
        
        if self.index is not None and self.labels is not None:
            try:
                # Support both list and numpy array for index.
                if isinstance(self.index, list):
                    pos = self.index.index(int(value))
                else:
                    pos = int(np.where(self.index == int(value))[0][0])
                return self.labels[pos]
            except (ValueError, IndexError):
                return "Unknown"
        elif self.labels is not None:
            try:
                return self.labels[int(value)]
            except (ValueError, IndexError):
                return "Unknown"
        return "Unknown"

    def get_region_name(self, value: Union[int, str]) -> str:
        """
        Return the region name corresponding to the given atlas value.
        """
        return self._get_region_name(value)

    def _get_region_index(self, label: str) -> Union[int, str]:
        """
        Return the numeric region index corresponding to the given label.
        
        :param label: The region name.
        :return: The region index.

        If `labels` is a dict, lookup is performed using string keys.
        If `labels` is array-like with a corresponding `index` array, the position is found.
        Returns "Unknown" if not found.
        """
        if not isinstance(label, str):
            raise ValueError("label must be a string")
        
        if self._label2index is not None:
            return self._label2index.get(label, "Unknown")
        
        if self.index is not None and self.labels is not None:
            try:
                if isinstance(self.labels, list):
                    pos = self.labels.index(label)
                else:
                    pos = int(np.where(np.array(self.labels) == label)[0][0])
                if isinstance(self.index, list):
                    return self.index[pos]
                else:
                    return self.index[pos]
            except (ValueError, IndexError):
                return "Unknown"
        elif self.labels is not None:
            try:
                return int(np.where(np.array(self.labels) == label)[0][0])
            except (ValueError, IndexError):
                return "Unknown"
        return "Unknown"
    
    def get_region_index(self, label: str) -> Union[int, str]:
        """
        Return the region index corresponding to the given label.
        """
        return self._get_region_index(label)

    def get_list_of_regions(self) -> List[str]:
        """
        Return a list of all unique region names in the atlas.

        :return: A list of region names.
        """
        if isinstance(self.labels, dict):
            return list(self.labels.values())
        elif self.labels is not None:
            return list(self.labels)
        else:
            return []

    def get_hemisphere(self, region: Union[int, str]) -> Optional[str]:
        """
        Return the hemisphere ('L' or 'R') inferred from the region name.
        
        :param region: The region index or name.
        :return: The hemisphere ('L' or 'R') or None if not found.
        """
        region_name = region if isinstance(region, str) else self.get_region_name(region)
        if region_name in (None, "Unknown"):
            return None
        region_lower = region_name.lower()
        if region_lower.endswith('_l'):
            return 'L'
        elif region_lower.endswith('_r'):
            return 'R'
        return None

    # --- Coordinate Conversion Methods ---

    def pos_to_source(self, pos: Union[List[float], np.ndarray]) -> Tuple[int, int, int]:
        """
        Convert an MNI coordinate (x, y, z) to voxel indices using the inverse of the affine transform.

        :param pos: The MNI coordinate (x, y, z).
        :return: The voxel indices (i, j, k).
        """
        if not isinstance(pos, (list, np.ndarray)):
            raise ValueError("`pos` must be a list or numpy array.")
        pos_arr = np.asarray(pos)
        if pos_arr.shape != (3,):
            raise ValueError("`pos` must be a 3-element coordinate (x, y, z).")
        homogeneous = np.append(pos_arr, 1)
        voxel = np.linalg.inv(self.hdr) @ homogeneous
        return tuple(map(int, np.round(voxel[:3])))

    def pos_to_index(self, pos: Union[List[float], np.ndarray]) -> Union[int, str]:
        """
        Return the atlas region index for a given MNI coordinate.

        :param pos: The MNI coordinate (x, y, z).
        :return: The region index or "Unknown".
        """
        if not isinstance(pos, (list, np.ndarray)):
            raise ValueError("`pos` must be a list or numpy array.")
        ijk = self.pos_to_source(pos)
        if any(i < 0 or i >= s for i, s in zip(ijk, self.shape)):
            return "Unknown"
        return int(self.vol[ijk])

    def pos_to_region(self, pos: Union[List[float], np.ndarray]) -> str:
        """
        Return the region name for a given MNI coordinate.

        :param pos: The MNI coordinate (x, y, z).
        :return: The region name or "Unknown".
        """
        if not isinstance(pos, (list, np.ndarray)):
            raise ValueError("`pos` must be a list or numpy array.")
        idx = self.pos_to_index(pos)
        if idx == "Unknown":
            return "Unknown"
        return self.get_region_name(idx)

    def source_to_pos(self, source: Union[List[int], np.ndarray]) -> Union[np.ndarray, np.ndarray]:
        """
        Convert voxel indices (i, j, k) to MNI coordinates using the affine transform.

        :param source: The voxel indices (i, j, k).
        :return: The MNI coordinates
        """
        if not isinstance(source, (list, np.ndarray)):
            raise ValueError("`source` must be a list or numpy array.")
        src_arr = np.atleast_2d(source)
        ones = np.ones((src_arr.shape[0], 1))
        homogeneous = np.hstack([src_arr, ones])
        transformed = homogeneous @ self.hdr.T
        coords = transformed[:, :3] / transformed[:, 3, np.newaxis]
        return coords if src_arr.shape[0] > 1 else coords[0]

    def index_to_pos(self, index: Union[int, str]) -> np.ndarray:
        """
        Return MNI coordinates for all voxels that have the specified atlas region index.

        :param index: The region index or name.
        :return: The MNI coordinates.
        """
        if not isinstance(index, (int, str)):
            raise ValueError("`index` must be an int or str.")
        try:
            idx = int(index)
        except ValueError:
            return np.empty((0, 3))
        coords = np.argwhere(self.vol == idx)
        if coords.size == 0:
            return np.empty((0, 3))
        return self.source_to_pos(coords)

    def region_to_pos(self, region: str) -> np.ndarray:
        """
        Return MNI coordinates for all voxels corresponding to the given region name.

        :param region: The region name.
        :return: The MNI coordinates
        """
        if not isinstance(region, str):
            raise ValueError("`region` must be a string.")
        idx = self.get_region_index(region)
        if idx == "Unknown":
            return np.empty((0, 3))
        return self.index_to_pos(idx)
    

class VectorizedAtlasRegionMapper:
    """
    Provides batch (vectorized) conversion methods for an AtlasRegionMapper.

    This class wraps an instance of AtlasRegionMapper (i.e., using AtlasRegionMapper)
    and applies its conversion methods (e.g., from MNI coordinates to voxel indices, region indexes,
    or region names) over a list or array of inputs.
    """

    def __init__(self, mapper: AtlasRegionMapper) -> None:
        """
        Initialize with an instance of AtlasRegionMapper.
        
        :param mapper: An instance of AtlasRegionMapper.
        """
        if not isinstance(mapper, AtlasRegionMapper):
            raise ValueError("mapper must be an instance of AtlasRegionMapper")
        self.mapper = mapper

    def batch_get_region_names(self, values: List[Union[int, str]]) -> List[str]:
        """
        Return region names corresponding to a list of region indexes/values.
        
        :param values: A list of region indexes or values.
        :return: A list of region names.
        """
        if not all(isinstance(val, (int, str)) for val in values):
            raise ValueError("values must be a list of ints or strings")
        return [self.mapper.get_region_name(val) for val in values]

    def batch_get_region_indices(self, labels: List[str]) -> List[Union[int, str]]:
        """
        Return region indexes corresponding to a list of region names.
        
        :param labels: A list of region names.
        :return: A list of region indexes.
        """
        if not all(isinstance(label, str) for label in labels):
            raise ValueError("labels must be a list of strings")
        return [self.mapper.get_region_index(label) for label in labels]

    def batch_pos_to_source(self, positions: Union[List[List[float]], np.ndarray]) -> List[tuple]:
        """
        Convert a batch of MNI coordinates to voxel indices.
        
        :param positions: An array-like of shape (N, 3) containing MNI coordinates.
        :return: A list of voxel indices (i, j, k) for each coordinate.
        """
        if not isinstance(positions, (list, np.ndarray)):
            raise ValueError("positions must be a list or numpy array")
        positions_arr = np.atleast_2d(positions)
        return [self.mapper.pos_to_source(pos) for pos in positions_arr]

    def batch_pos_to_index(self, positions: Union[List[List[float]], np.ndarray]) -> List[Union[int, str]]:
        """
        Convert a batch of MNI coordinates to atlas region indexes.
        
        :param positions: An array-like of shape (N, 3) containing MNI coordinates.
        :return: A list of region indexes corresponding to each coordinate.
        """
        if not isinstance(positions, (list, np.ndarray)):
            raise ValueError("positions must be a list or numpy array")
        positions_arr = np.atleast_2d(positions)
        return [self.mapper.pos_to_index(pos) for pos in positions_arr]

    def batch_pos_to_region(self, positions: Union[List[List[float]], np.ndarray]) -> List[str]:
        """
        Convert a batch of MNI coordinates to region names.
        
        :param positions: An array-like of shape (N, 3) containing MNI coordinates.
        :return: A list of region names corresponding to each coordinate.
        """
        if not isinstance(positions, (list, np.ndarray)):
            raise ValueError("positions must be a list or numpy array")
        positions_arr = np.atleast_2d(positions)
        return [self.mapper.pos_to_region(pos) for pos in positions_arr]

    def batch_source_to_pos(self, sources: Union[List[List[int]], np.ndarray]) -> np.ndarray:
        """
        Convert a batch of voxel indices to MNI coordinates.
        
        :param sources: An array-like of shape (N, 3) containing voxel indices.
        :return: An array of MNI coordinates for each voxel.
        """
        if not isinstance(sources, (list, np.ndarray)):
            raise ValueError("sources must be a list or numpy array")
        sources_arr = np.atleast_2d(sources)
        return np.array([self.mapper.source_to_pos(src) for src in sources_arr])

    def batch_index_to_pos(self, indices: List[Union[int, str]]) -> List[np.ndarray]:
        """
        For each region index in the list, return an array of MNI coordinates for voxels
        having that index.
        
        :param indices: A list of region indexes.
        :return: A list where each element is an array of MNI coordinates for the corresponding index.
        """
        if not all(isinstance(idx, (int, str)) for idx in indices):
            raise ValueError("indices must be a list of ints or strings")
        return [self.mapper.index_to_pos(idx) for idx in indices]

    def batch_region_to_pos(self, regions: List[str]) -> List[np.ndarray]:
        """
        For each region name in the list, return an array of MNI coordinates for voxels
        corresponding to that region.
        
        :param regions: A list of region names.
        :return: A list where each element is an array of MNI coordinates for the corresponding region.
        """
        if not all(isinstance(region, str) for region in regions):
            raise ValueError("regions must be a list of strings")
        return [self.mapper.region_to_pos(region) for region in regions]


class coord2region:
    """
    Processes region mapping and coordinate conversions across multiple atlases.
    
    This class accepts a dictionary of atlas mappers (keyed by atlas name) and
    provides methods to perform coordinate conversions and mapping queries on all atlases,
    returning results in a standardized dictionary.
    """
    def __init__(self, data_dir: str, atlases: Dict[str, Dict[str, Any]]) -> None:
        """
        Initialize by fetching atlases from provided kwargs and wrapping them in VectorizedAtlasRegionMapper.
        
        :param data_dir: The directory where atlas data is stored.
        :param atlases: A dictionary of atlas names and their kwargs.
        """
        self.mappers = {}
        atlas_fetcher = AtlasFetcher()
        # self.data_dir = AtlasFetcher.data_dir
        print(atlases)
        for name, kwargs in atlases.items():
            atlas = atlas_fetcher.fetch_atlas(name, **kwargs)
            mapper = AtlasRegionMapper(name=name, vol=atlas["vol"], hdr=atlas["hdr"], labels=atlas["labels"])
            vectorized_mapper = VectorizedAtlasRegionMapper(mapper)
            self.mappers[name] = vectorized_mapper

    def batch_pos_to_region(self, positions: Union[List[List[float]], np.ndarray]) -> Dict[str, List[str]]:
        """
        Convert a batch of MNI coordinates to region names for all atlases.
        
        :param positions: An array-like of shape (N, 3) containing MNI coordinates.
        :return: A dictionary keyed by atlas name, with lists of region names.
        """
        if not isinstance(positions, (list, np.ndarray)):
            raise ValueError("positions must be a list or numpy array")
        results = {}
        for atlas_name, mapper in self.mappers.items():
            results[atlas_name] = mapper.batch_pos_to_region(positions)
        return results

    def batch_region_to_pos(self, regions: List[str]) -> Dict[str, List[np.ndarray]]:
        """
        Convert a list of region names to MNI coordinates for all atlases.
        
        :param regions: A list of region names.
        :return: A dictionary keyed by atlas name, with lists of MNI coordinates.
        """
        if not all(isinstance(region, str) for region in regions):
            raise ValueError("regions must be a list of strings")
        results = {}
        for atlas_name, mapper in self.mappers.items():
            results[atlas_name] = mapper.batch_region_to_pos(regions)
        return results

# File: .\fetching.py
import os
import logging
import numpy as np
from typing import Optional
  
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)


class AtlasFileHandler:
    """
    Handles file operations for atlas fetching.
    
    This class provides utility functions to:
      - Load local atlas files.
      - Download atlases from a URL.
      - Package files into a standardized dictionary with keys:
          'vol', 'hdr', 'labels', 'description', and 'file'.
    """
    def __init__(self, data_dir: Optional[str] = None):
        """
        :param data_dir: Directory to store/download atlas files.
             Defaults to a 'data' folder within a hidden '.coord2region' folder in the user's home directory.
        """
        # TODO check if the data_dir is a valid path
        # TODO check if data_dir is an absolute path before assigning home_dir
        home_dir = os.path.expanduser("~")
        if data_dir is None:
            self.data_dir = os.path.join(home_dir, 'coord2region_data')
        else:
            self.data_dir = os.path.join(home_dir, data_dir)
        os.makedirs(self.data_dir, exist_ok=True)
        self.nilearn_data = os.path.join(home_dir, 'nilearn_data')
        self.mne_data = os.path.join(home_dir, 'mne_data')

    def _fetch_labels(self, fname: str):
        """
        Attempt to fetch labels from a corresponding XML or TXT file.
        
        :param fname: The file name of the atlas image.
        :return: A dictionary of labels if found, else None.
        """
        base, _ = os.path.splitext(fname)        
        fname_xml = base + '.xml'

        # get parent directory
        # TODO use os.path.join instead of + for clarity and cross-platform compatibility
        # TODO use os.path.splitext instead of string manipulation
        # TODO Consider parameterizing these
        base_dir = os.path.dirname(fname)
        if "HarvardOxford" in base_dir:
            fname_xml = base_dir + "-Cortical.xml"
        if "Juelich" in base_dir:
            fname_xml = base_dir + ".xml"
        if os.path.exists(fname_xml):
            try:
                import xml.etree.ElementTree as ET
                tree = ET.parse(fname_xml)
                root = tree.getroot()
                labels = {}
                for label in root.find("data").findall("label"):
                    index = label.find("index").text
                    name = label.find("name").text
                    labels[index] = name
                return labels
            except Exception as e:
                logger.warning(f"Failed to parse XML labels: {e}")
        else:
            # TODO improve error handling
            fname_txt = base + '.txt'
            if "schaefer" in base_dir:
                fname_txt = os.path.join(base_dir, "Schaefer2018_400Parcels_7Networks_order.txt")
            if os.path.exists(fname_txt):
                with open(fname_txt, 'r') as f:
                    lines = f.readlines()
                labels = {str(idx): line.strip() for idx, line in enumerate(lines)}
                return labels
        logger.warning(f"Failed to fetch labels")
        return None

    def pack_vol_output(self, fname: str, desc: str = None):
        """
        Load an atlas file into a nibabel image (or numpy archive) and package it.
        
        :param fname: Path to the atlas file.
        :param desc: Short description.
        :return: A dictionary with keys: 'vol', 'hdr', 'labels', 'description', 'file'.
        :raises ValueError: If file format is unrecognized.
        """
        path = os.path.abspath(fname)
        _, ext = os.path.splitext(fname)
        ext = ext.lower()

        if ext in ['.nii', '.gz', '.nii.gz']:
            # TODO add try-except block for loading the image
            import nibabel as nib
            img = nib.load(fname)
            vol_data = img.get_fdata(dtype=np.float32)
            hdr_matrix = img.affine
            labels = self._fetch_labels(path)
            return {
                'vol': vol_data,
                'hdr': hdr_matrix,
                'labels': labels,
                'description': desc,
                'file': fname
            }
        elif ext == '.npz':
            # TODO add try-except block for loading the archive
            arch = np.load(path, allow_pickle=True)
            vol_data = arch['vol']
            hdr_matrix = arch['hdr']
            labels = None
            if 'labels' in arch and 'index' in arch:
                labels = {idx: name for idx, name in zip(arch['index'], arch['labels'])}
            return {
                'vol': vol_data,
                'hdr': hdr_matrix,
                'labels': labels,
                'description': desc,
                'file': fname
            }
        else:
            raise ValueError(f"Unrecognized file format '{ext}' for path: {path}")

    def pack_surf_output(self, subject: str, subjects_dir: str, parc: str = 'aparc', **kwargs):
        """
        Load surface-based atlas using MNE from FreeSurfer annotation files.

        :param subject: The subject identifier (e.g., 'fsaverage').
        :param subjects_dir: Path to the FreeSurfer subjects directory.
        :param parc: The parcellation name (e.g., 'aparc', 'aparc.a2009s').
        :param kwargs: Additional keyword arguments.
        :return: A dictionary with keys: 'vmap', 'labmap', 'mni'.
                """
        import mne
        src = mne.read_source_spaces(os.path.join(subjects_dir, subject, 'bem', f'{subject}-ico-5-src.fif'), verbose=False)
        labels = mne.read_labels_from_annot(subject, parc=parc, subjects_dir=subjects_dir, verbose=False)
        lh_vert = src[0]['vertno']
        rh_vert = src[1]['vertno']
    
        cortex_dict = {
            label.name: (np.searchsorted(lh_vert, np.intersect1d(lh_vert, label.vertices))
                        if label.hemi == 'lh'
                        else len(lh_vert) + np.searchsorted(rh_vert, np.intersect1d(rh_vert, label.vertices)))
            for label in labels
        }

        labmap = {v: lab for lab, verts in cortex_dict.items() for v in np.atleast_1d(verts)}

        # Compute MNI coordinates for the cortical parts (assuming first two hemispheres)
        mni_list = mne.vertex_to_mni([lh_vert, rh_vert], [0, 1], subject, subjects_dir=subjects_dir)
        mni_coords = np.concatenate(mni_list, axis=0)
        # TODO improve consistency in the output format
        return {
            'vmap': cortex_dict,
            'labmap': labmap,
            'mni': mni_coords
        }

    def fetch_from_local(self, atlas_path: str):
        """
        Load an atlas from a local file.
        
        :param atlas_path: Path to the local atlas file.
        :return: The standardized atlas dictionary.
        """
        logger.info(f"Loading local atlas file: {atlas_path}")
        return self.pack_vol_output(atlas_path, desc="Local file")

    def fetch_from_url(self, atlas_url: str, **kwargs):
        """
        Download an atlas from a URL (if not already present) and load it.
        
        :param atlas_url: The URL of the atlas.
        :param kwargs: Additional parameters.
        :return: The standardized atlas dictionary.
        :raises RuntimeError: if the download fails.
        """
        # TODO document that the file name is expected to be in the URL
        import urllib.parse
        import requests
        #requests.packages.urllib3.disable_warnings()
        parsed = urllib.parse.urlparse(atlas_url)
        file_name = os.path.basename(parsed.path)
        if not file_name:
            file_name = "atlas_download.nii.gz"
        local_path = os.path.join(self.data_dir, file_name)

        if not os.path.exists(local_path):
            logger.info(f"Downloading atlas from {atlas_url}...")
            try:
                with requests.get(atlas_url, stream=True, timeout=30, verify=False) as r:
                    r.raise_for_status()
                    with open(local_path, 'wb') as f:
                        for chunk in r.iter_content(chunk_size=8192):
                            if chunk:
                                f.write(chunk)
                logger.info(f"Atlas downloaded to {local_path}")
            except Exception as e:
                if os.path.exists(local_path):
                    os.remove(local_path)
                logger.exception(f"Failed to download from {atlas_url}")
                raise RuntimeError(f"Failed to download from {atlas_url}") from e
        else:
            logger.info(f"Atlas already exists: {local_path}. Skipping download.")

        return local_path


class AtlasFetcher:
    """
    Fetches neuroimaging atlases using various methods.
    
    This class uses an AtlasFileHandler instance for file operations and provides atlas-specific
    fetchers. Supported atlas identifiers include volumetric atlases such as:
      - "aal", "brodmann", "harvard-oxford", "juelich", "schaefer", "yeo", "aparc2009"
    
    In addition, this module now supports MNE-based, surface annotation atlases via:
      - "mne-annot" (generic annotation; requires keyword arguments 'subject' and 'subjects_dir')
      - "mne-aparc2009" (a convenience key that sets parc to 'aparc.a2009s')
      
    Each fetcher returns a standardized dictionary. For volumetric atlases the keys are:
      'vol', 'hdr', 'labels', 'description', 'file'.
    For MNE annotation atlases, additional keys include:
      'vmap' (label to vertex mapping), 'labmap' (vertex-to-label mapping), and 'mni' (MNI coordinates).
    """

    # Fallback URL for Talairach atlas .
    ATLAS_URLS = {
        'talairach': 'https://www.talairach.org/talairach.nii',
        'aal': 'http://www.gin.cnrs.fr/wp-content/uploads/AAL3v2_for_SPM12.tar.gz',
    }

    def __init__(self, data_dir: str = None):
        """
        :param data_dir: Directory to store/download atlas files.
        """

        self.file_handler = AtlasFileHandler(data_dir=data_dir)
        self.data_dir = self.file_handler.data_dir
        self.nilearn_data = self.file_handler.nilearn_data
        self.mne_data = self.file_handler.mne_data
        self._atlas_fetchers = {
            #"aal": self._fetch_atlas_aal,
            "brodmann": self._fetch_atlas_brodmann,
            "harvard-oxford": self._fetch_atlas_harvard_oxford,
            "juelich": self._fetch_atlas_juelich,
            "schaefer": self._fetch_atlas_schaefer,
            "yeo": self._fetch_atlas_yeo,
            # MNE-based atlases:
            "aparc2009": self._fetch_atlas_aparc2009,
        }

    # ---- Volumetric atlas fetchers using Nilear ----

    def _fetch_atlas(self, fetcher, **kwargs):
        try:
            return fetcher(data_dir=self.file_handler.data_dir, **kwargs)
        except Exception as e:
            logger.error("Failed to fetch atlas using primary data_dir: %s", e, exc_info=True)
            return fetcher(data_dir=self.file_handler.nilearn_data, **kwargs)

    def _fetch_atlas_aal(self, **kwargs):
        try:
            from nilearn.datasets import fetch_atlas_aal
            kwargs["version"] = kwargs.get('version', 'SPM12') # TODO: add versions
            fetched = self._fetch_atlas(fetch_atlas_aal, **kwargs)
            return self.file_handler.pack_vol_output(fetched["maps"], desc="AAL Atlas")
        except:
            # Fallback URL for AAL atlas.
            return self.file_handler.fetch_from_url(self.ATLAS_URLS.get('aal'))
    
    def _fetch_atlas_brodmann(self, **kwargs):
        try:
            from nilearn.datasets import fetch_atlas_talairach
            fetched = self._fetch_atlas(fetch_atlas_talairach, level_name="ba", **kwargs)
            return self.file_handler.pack_vol_output(fetched["maps"], desc="Talairach Atlas")
        except:
            # Fallback URL for Talairach atlas.
            return self.file_handler.fetch_from_url(self.ATLAS_URLS.get('talairach'))

    def _fetch_atlas_harvard_oxford(self, **kwargs):
        from nilearn.datasets import fetch_atlas_harvard_oxford
        atlas_name = kwargs.get('version', 'cort-maxprob-thr25-2mm')
        fetched = self._fetch_atlas(fetch_atlas_harvard_oxford, atlas_name=atlas_name, **kwargs)
        output = {
            'vol': fetched.get('maps', None).get_fdata(dtype=np.float32) if fetched.get('maps', None) else None,
            'hdr': fetched.get('maps', None).affine if fetched.get('maps', None) else None,
            'labels': fetched.get('labels', None),
            'description': fetched.get('description', None),
            'file': fetched.get('filename', None)
        }
        return output

    def _fetch_atlas_juelich(self, **kwargs):
        from nilearn.datasets import fetch_atlas_juelich
        atlas_name = kwargs.get('version', 'maxprob-thr0-1mm')
        fetched = fetched = self._fetch_atlas(fetch_atlas_juelich, atlas_name=atlas_name, **kwargs)
        return self.file_handler.pack_vol_output(fetched["filename"], desc=f"Juelich {atlas_name} Atlas")

    def _fetch_atlas_schaefer(self, **kwargs):
        from nilearn.datasets import fetch_atlas_schaefer_2018
        fetched = self._fetch_atlas(fetch_atlas_schaefer_2018, **kwargs)
        return self.file_handler.pack_vol_output(fetched["maps"], desc="Schaefer 2018 Atlas")

    def _fetch_atlas_yeo(self, **kwargs):
        from nilearn.datasets import fetch_atlas_yeo_2011
        fetched = self._fetch_atlas(fetch_atlas_yeo_2011, **kwargs)
        version = kwargs.get('version', 'thick_17')
        return self.file_handler.pack_vol_output(fetched[version], desc=f"Yeo 2011 {version} Atlas")

    # ---- MNE-based (surface annotation) atlas fetcher ----
    
    def _fetch_atlas_aparc2009(self, **kwargs):
        return self.file_handler.pack_surf_output(parc='aparc.a2009s', **kwargs)
    
    # ---- Public method ----

    def fetch_atlas(self, atlas_name: str, atlas_url: str = None, version: str = None, **kwargs):
        """
        Fetch an atlas given an atlas identifier.
        
        The identifier can be:
            (a) A URL (starting with http:// or https://),
            (b) A local file path,
            (c) Nilearn or mne atlases atlases (e.g., "aal", "harvard-oxford", "aparc2009", "mne-annot", etc.).
        
        For MNE-based atlases (keys starting with "mne-"), additional keyword arguments are required:
            - subject: subject identifier (e.g., "fsaverage")
            - subjects_dir: path to the FreeSurfer subjects directory
        
        :param atlas_name: The atlas identifier or file path.
        :param version: Version specifier (used for certain atlases, e.g., AAL).
        :param atlas_url: (Optional) Override URL for fetching the atlas.
        :param kwargs: Additional keyword arguments for the specific fetcher.
        :return: A standardized atlas dictionary.
        :raises ValueError: if the atlas identifier is not recognized.
        """
        # Case (a): URL provided.
        if atlas_url is not None and (atlas_url.startswith('http://') or atlas_url.startswith('https://')):
            return self.file_handler.fetch_from_url(atlas_url, **kwargs)
        
        # Case (b): Local file path.
        atlas_file = kwargs.get("atlas_file")
        if atlas_file and os.path.isfile(atlas_file):
            return self.file_handler.fetch_from_local(atlas_file)
        elif os.path.isfile(os.path.join(self.data_dir, atlas_name)):
            return self.file_handler.fetch_from_local(os.path.join(self.data_dir, atlas_name))
    
        # Case (c): nilearn or mne atlases.
        key = atlas_name.lower()
        fetcher = self._atlas_fetchers.get(key)
        if fetcher:
            return fetcher(**kwargs)
    
        raise ValueError(f"Unrecognized atlas name '{atlas_name}'. Available options: {list(self._atlas_fetchers.keys())}.")


# Example usage: # remove later
if __name__ == '__main__':
    af = AtlasFetcher(data_dir="atlas_data")
    # TODO: fix fetch using url!
    # atlas = af.fetch_atlas("aal", atlas_url="https://www.gin.cnrs.fr/wp-content/uploads/AAL3v2_for_SPM12.tar.gz")
    # logger.info(f"Fetched atlas: {atlas['description']} from file: {atlas['file']}")
    # atlas = af.fetch_atlas("talairach", atlas_url="https://www.talairach.org/talairach.nii")
    # logger.info(f"Fetched atlas: {atlas['description']} from file: {atlas['file']}")

    # TODO: test fetch from local file

    # TODO add "destrieux": self._fetch_atlas_destrieux, similar to mne-annot
    # TODO brodmann: self._fetch_atlas_brodmann is not downloading the file
    # TODO harvard-oxford: self._fetch_atlas_harvard_oxford fix labels fetching for this atlas
    # TODO juilich: self._fetch_atlas_juelich fix labels fetching for this atlas
    # TODO schaefer: self._fetch_atlas_schaefer check if labels are extracted correctly
    # TODO yeo: self._fetch_atlas_yeo check label extraction from description file
    # TODO add other nibabel, nilearn, mne atlases
    # atlas = af.fetch_atlas("yeo")
    # print(isinstance(atlas, dict))
    # print(atlas.keys())
    # print(atlas["labels"])

    # TODO: test fetching a surface-based atlas
    # atlas = af.fetch_atlas("mne-annot", subject="fsaverage", subjects_dir="mne_data")
    # print(isinstance(atlas, dict))

    # TODO: add save/load methods for created atlases
    # TODO: make output of fetch_atlas consistent
    # TODO: add method to list available atlases
    # TODO: refactor to use a single fetch method for all atlases
    # TODO: add method to fetch all atlases at once
    # TODO: check for atlases that supported by both mne and nilearn if else


# File: .\test_coord2region.py
import pytest
import numpy as np

from coord2region.fetching import AtlasFetcher
from coord2region.coord2region import (
    AtlasRegionMapper,
    VectorizedAtlasRegionMapper,
    coord2region
)

# ---------------------- Fixtures ---------------------- #
@pytest.fixture(scope="module")
def harvard_atlas():
    """Fetch the Harvard-Oxford atlas as our test fixture."""
    af = AtlasFetcher()
    return af.fetch_atlas("harvard-oxford")


@pytest.fixture(scope="module")
def harvard_mapper(harvard_atlas):
    """Create the AtlasRegionMapper instance for Harvard-Oxford."""
    return AtlasRegionMapper(
        name="harvard-oxford",
        vol=harvard_atlas["vol"],
        hdr=harvard_atlas["hdr"],
        labels=harvard_atlas["labels"]
    )


@pytest.fixture(scope="module")
def harvard_vectorized_mapper(harvard_mapper):
    """Create the VectorizedAtlasRegionMapper from the single AtlasRegionMapper."""
    return VectorizedAtlasRegionMapper(harvard_mapper)


@pytest.fixture(scope="module")
def c2r_mapper():
    """
    Create a coord2region instance that includes the Harvard-Oxford atlas
    under the key "harvard-oxford".
    """
    return coord2region.coord2region("coord2region_data", {"harvard-oxford": {}})


# ---------------------- Tests for AtlasRegionMapper ---------------------- #
def test_get_hemisphere(harvard_mapper):
    hemisphere = harvard_mapper.get_hemisphere("Frontal Pole")
    # Depending on how your "Frontal Pole" label is set, it might return 'L', 'R', or None
    # if that label doesn't follow the naming convention with '_L' or '_R'.
    # For demonstration, we only assert that the function runs and returns something valid.
    assert hemisphere in ("L", "R", None)

def test_get_region_name_unknown(harvard_mapper):
    # Pass an integer that doesn't exist in the atlas volume
    region = harvard_mapper.get_region_name(999999)
    assert region == "Unknown"

def test_get_region_index(harvard_mapper):
    # Example region that definitely exists in Harvard-Oxford
    index = harvard_mapper.get_region_index("Precentral Gyrus")
    assert index != "Unknown"
    assert isinstance(index, int)

def test_list_of_regions(harvard_mapper):
    # We expect a non-empty list
    regions = harvard_mapper.get_list_of_regions()
    assert isinstance(regions, list)
    assert len(regions) > 0
    assert "Frontal Pole" in regions  # example check

def test_pos_to_source_and_back(harvard_mapper):
    # We'll pick a coordinate (x, y, z) in MNI space near the left frontal area
    pos = [-54., 36., -4.]
    source_ijk = harvard_mapper.pos_to_source(pos)
    assert len(source_ijk) == 3  # Should be a tuple (i, j, k)
    # Round trip test
    mni_again = harvard_mapper.source_to_pos(source_ijk)
    # Because of rounding in voxel space, we expect them to be close but not identical
    np.testing.assert_almost_equal(mni_again, pos, decimal=1)

def test_pos_to_index_and_region(harvard_mapper):
    pos = [-54., 36., -4.]
    idx = harvard_mapper.pos_to_index(pos)
    # idx can be 0 or "Unknown" if the coordinate is out of atlas bounds
    if idx != "Unknown":
        region = harvard_mapper.pos_to_region(pos)
        # We can't guarantee which region it belongs to, but it shouldn't be "Unknown"
        assert region != "Unknown"


# ---------------------- Tests for VectorizedAtlasRegionMapper ---------------------- #
def test_batch_get_region_names_indices(harvard_vectorized_mapper):
    # Suppose 2, 3, 4 are valid indices in the Harvard-Oxford volume
    region_names = harvard_vectorized_mapper.batch_get_region_names([2, 3, 4])
    # Just check that we got valid region names (none of them should be "Unknown" if they exist)
    assert all(name != "Unknown" for name in region_names)

    # Now convert them back to indices
    retrieved_indices = harvard_vectorized_mapper.batch_get_region_indices(region_names)
    # They should match the original [2, 3, 4] except for potential mismatch if some were missing
    for orig_i, ret_i in zip([2, 3, 4], retrieved_indices):
        if ret_i != "Unknown":
            assert orig_i == ret_i

def test_batch_pos_functions(harvard_vectorized_mapper, harvard_mapper):
    # Let's build a small set of coordinates (one for each region) for testing:
    # We'll just pick the 3rd voxel in each region for demonstration
    regions = harvard_mapper.get_list_of_regions()
    coords_list = []
    for reg in regions[:5]:
        # skip background
        if reg.lower() == "background":
            continue
        region_coords = harvard_mapper.region_to_pos(reg)
        if region_coords.shape[0] < 3:
            continue
        # pick the 3rd voxel for reproducibility
        coords_list.append(region_coords[2])

    # Now test the vectorized calls
    region_names = harvard_vectorized_mapper.batch_pos_to_region(coords_list)
    # Should all be valid (but not guaranteed if some coords are out-of-bounds or partial)
    assert len(region_names) == len(coords_list)

    region_indices = harvard_vectorized_mapper.batch_pos_to_index(coords_list)
    assert len(region_indices) == len(coords_list)

    # Convert these positions to voxel indices
    voxel_indices = harvard_vectorized_mapper.batch_pos_to_source(coords_list)
    assert len(voxel_indices) == len(coords_list)

    # Convert those voxels back to MNI coords
    mni_coords = harvard_vectorized_mapper.batch_source_to_pos(voxel_indices)
    # Should shape-match
    assert mni_coords.shape == (len(coords_list), 3)


# ---------------------- Tests for coord2region.coord2region ---------------------- #
def test_coord2region_batch_pos_to_region(c2r_mapper, harvard_mapper):
    # We'll reuse the same idea of picking a few MNI coords from known regions:
    regions = harvard_mapper.get_list_of_regions()[:5]
    coords_list = []
    for reg in regions:
        if reg.lower() == "background":
            continue
        region_coords = harvard_mapper.region_to_pos(reg)
        if region_coords.shape[0] == 0:
            continue
        coords_list.append(region_coords[0])  # just pick the first voxel

    result = c2r_mapper.batch_pos_to_region(coords_list)
    # result is a dict keyed by atlas name, in this case {"harvard-oxford": [...]}
    assert "harvard-oxford" in result
    assert len(result["harvard-oxford"]) == len(coords_list)


def test_coord2region_batch_region_to_pos(c2r_mapper):
    region_names = [
        "Occipital Fusiform Gyrus",
        "Frontal Opercular Cortex",
        "Central Opercular Cortex",
        "Parietal Opercular Cortex",
        "Planum Polare",
    ]
    result = c2r_mapper.batch_region_to_pos(region_names)
    # Should be keyed by "harvard-oxford"
    assert "harvard-oxford" in result
    for coords_array in result["harvard-oxford"]:
        # Each entry is an array of MNI coordinates
        assert isinstance(coords_array, np.ndarray)
        # We can't assume they aren't empty, but let's just show the call worked.


# File: .\__init__.py
from .coord2region import AtlasRegionMapper
from .fetching import AtlasFetcher

# File: .\utils\utils.py
import os



# File: .\utils\__init__.py
from .utils import _fetch_labels


